CREATE OR REPLACE PROCEDURE WEALTHMAKER.PSM_MF_RECO_M_RECONCILE3(
    P_TRAN_CODE      IN VARCHAR2,
    P_TR_TRAN        IN VARCHAR2,
    P_RTA_AMOUNT     IN NUMBER,
    P_RTA_TRAN_CODE  IN VARCHAR2,
    P_LOGIN_ID       IN VARCHAR2,
    P_ROLE_ID        IN VARCHAR2,
    P_CURSOR        OUT SYS_REFCURSOR    
)  
AS
    V_COUNT1 NUMBER := 0;
    V_COUNT2 NUMBER := 0;
    V_COUNT3 NUMBER := 0;
    V_ERROR_MSG VARCHAR2(4000);
    MyDispatch VARCHAR2(10) := 'N';
    MyRtaTrCode_1 VARCHAR2(400);
    MyTrCode VARCHAR2(20);
    MyRtaAmount NUMBER;
    Glbloginid VARCHAR2(100);
    MyRtaFolio VARCHAR2(100);
    MyRtaTrDate VARCHAR2(100);
    MyRtaTrCode VARCHAR2(400);
    
    -- Function to sanitize input strings
    FUNCTION SANITIZE_STRING(p_input IN VARCHAR2) RETURN VARCHAR2 IS
        v_output VARCHAR2(4000);
    BEGIN
        -- Remove single quotes, double quotes, and other special characters
        v_output := REGEXP_REPLACE(p_input, '[''"\\;]', '');
        -- Trim whitespace
        v_output := TRIM(v_output);
        -- Convert to uppercase if needed
        v_output := UPPER(v_output);
        RETURN v_output;
    EXCEPTION
        WHEN OTHERS THEN
            RETURN NULL;
    END SANITIZE_STRING;
    
    -- Function to validate date format
    FUNCTION VALIDATE_DATE(p_date IN VARCHAR2, p_format IN VARCHAR2) RETURN BOOLEAN IS
        v_date DATE;
    BEGIN
        v_date := TO_DATE(p_date, p_format);
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            RETURN FALSE;
    END VALIDATE_DATE;
    
BEGIN
    -- Initialize and sanitize variables
    MyTrCode := SANITIZE_STRING(P_TRAN_CODE);
    MyRtaAmount := NVL(P_RTA_AMOUNT, 0);
    Glbloginid := SANITIZE_STRING(P_LOGIN_ID);
    MyRtaTrCode_1 := SANITIZE_STRING(P_RTA_TRAN_CODE);
    MyRtaTrCode := SANITIZE_STRING(P_RTA_TRAN_CODE);
    
    -- Validate critical parameters
    IF MyTrCode IS NULL OR MyRtaTrCode IS NULL OR Glbloginid IS NULL THEN
        RAISE_APPLICATION_ERROR(-20001, 'Mandatory parameters (TRAN_CODE, RTA_TRAN_CODE, LOGIN_ID) cannot be null or invalid');
    END IF;
    
    -- Validate amount
    IF MyRtaAmount <= 0 THEN
        RAISE_APPLICATION_ERROR(-20004, 'RTA amount must be positive');
    END IF;
    
    -- Initialize output cursor
    OPEN P_CURSOR FOR 
    SELECT 'Procedure started with sanitized parameters' AS MESSAGE FROM DUAL;
    
    -- Begin transaction
    SAVEPOINT START_TRANSACTION;
    
    IF MyDispatch = 'N' THEN
        -- Update Transaction_mf_temp1 by TRAN_CODE with sanitized data
        UPDATE Transaction_mf_temp1 
        SET amount = MyRtaAmount, 
            REC_FLAG = 'Y',
            RECO_DATE = SYSDATE,
            REC_USER = Glbloginid,
            RTA_TRAN_CODE = MyRtaTrCode_1
        WHERE TRAN_CODE = MyTrCode;
        
        V_COUNT1 := SQL%ROWCOUNT;
       
        -- Update Transaction_mf_temp1 by BASE_TRAN_CODE with sanitized data
        UPDATE Transaction_mf_temp1 
        SET amount = MyRtaAmount, 
            REC_FLAG = 'Y',
            RECO_DATE = SYSDATE,
            REC_USER = Glbloginid,
            RTA_TRAN_CODE = MyRtaTrCode_1
        WHERE BASE_TRAN_CODE = MyTrCode;
        
        V_COUNT2 := SQL%ROWCOUNT;
       
        -- Update remote table with sanitized data
        UPDATE Transaction_st@MF.BAJAJCAPITAL 
        SET REC_FLAG = 'Y',
            HO_TRAN_CODE = MyTrCode 
        WHERE tran_code = MyRtaTrCode;
        
        V_COUNT3 := SQL%ROWCOUNT;
    ELSE 
        -- Additional validation for date if present
        IF MyRtaTrDate IS NOT NULL AND NOT VALIDATE_DATE(MyRtaTrDate, 'DD/MM/YYYY') THEN
            RAISE_APPLICATION_ERROR(-20005, 'Invalid transaction date format. Expected DD/MM/YYYY');
        END IF;
        
        IF P_TR_TRAN = 'TRAIL' THEN
            -- Update without transaction date
            UPDATE Transaction_mf_temp1 
            SET amount = MyRtaAmount,
                folio_no = SANITIZE_STRING(MyRtaFolio),
                REC_FLAG = 'Y',
                RECO_DATE = SYSDATE,
                REC_USER = Glbloginid,
                RTA_TRAN_CODE = MyRtaTrCode_1
            WHERE TRAN_CODE = MyTrCode;
            
            UPDATE Transaction_mf_temp1 
            SET amount = MyRtaAmount,
                folio_no = SANITIZE_STRING(MyRtaFolio),
                REC_FLAG = 'Y',
                RECO_DATE = SYSDATE,
                REC_USER = Glbloginid,
                RTA_TRAN_CODE = MyRtaTrCode_1
            WHERE BASE_TRAN_CODE = MyTrCode;
        ELSE
            -- Update with validated transaction date
            UPDATE Transaction_mf_temp1 
            SET amount = MyRtaAmount,
                folio_no = SANITIZE_STRING(MyRtaFolio),
                tr_date = TO_DATE(MyRtaTrDate, 'DD/MM/YYYY'),
                REC_FLAG = 'Y',
                RECO_DATE = SYSDATE,
                REC_USER = Glbloginid,
                RTA_TRAN_CODE = MyRtaTrCode_1
            WHERE TRAN_CODE = MyTrCode;
            
            UPDATE Transaction_mf_temp1 
            SET amount = MyRtaAmount,
                folio_no = SANITIZE_STRING(MyRtaFolio),
                REC_FLAG = 'Y',
                RECO_DATE = SYSDATE,
                REC_USER = Glbloginid,
                RTA_TRAN_CODE = MyRtaTrCode_1
            WHERE BASE_TRAN_CODE = MyTrCode;
        END IF;
        
        UPDATE Transaction_st@MF.BAJAJCAPITAL 
        SET REC_FLAG = 'Y',
            HO_TRAN_CODE = MyTrCode
        WHERE tran_code = MyRtaTrCode;
    END IF;

    -- Check if any updates were made
    IF V_COUNT1 = 0 AND V_COUNT2 = 0 THEN
        RAISE_APPLICATION_ERROR(-20002, 'No records found with TRAN_CODE or BASE_TRAN_CODE = ' || MyTrCode);
    END IF;
    
    IF V_COUNT3 = 0 THEN
        RAISE_APPLICATION_ERROR(-20003, 'No records found in remote table with TRAN_CODE = ' || MyRtaTrCode);
    END IF;
    
    -- Commit transaction
    COMMIT;
    
    -- Return success message
    OPEN P_CURSOR FOR 
    SELECT 'SUCCESS: Reconciliation completed with ' || 
           V_COUNT1 || ' primary record(s), ' ||
           V_COUNT2 || ' base record(s), and ' ||
           V_COUNT3 || ' remote record(s) updated' AS MESSAGE
    FROM DUAL;
    
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK TO START_TRANSACTION;
        V_ERROR_MSG := SQLERRM;
        OPEN P_CURSOR FOR 
        SELECT 'ERROR: ' || V_ERROR_MSG AS MESSAGE FROM DUAL;
END;
/